# -----------------------------------------------
# IMAGE REGISTRY AND REPOSITORY DETAILS
# -----------------------------------------------
image:
  registry: docker.io
  username:
  password:
  repository: esridocker
  tag: 11.3.0.5814

# -----------------------------------------------
# INSTALL INPUTS
# -----------------------------------------------
install:
  #
  # The fully qualified domain name (FQDN) to access ArcGIS Enterprise on
  # Kubernetes. This FQDN points to a load balancer, reverse proxy, edge
  # router, or other web front-end configured to route traffic to the ingress
  # controller. For example: <hostname>.<Domain>.com
  enterpriseFQDN:
  #
  # Enter the context path to be used in the URL for ArcGIS Enterprise on
  # Kubernetes. For example, the context path of 'https://<FQDN>/arcgis/admin'
  # would be 'arcgis'. The path needs to be single level; more than one level
  # is not supported.
  context: arcgis
  #
  # Set allowedPrivilegedContainers to false if you cannot run a privileged
  # container. Additionally, you will need to set vm.max_map_count to 262144
  # on each node.
  allowedPrivilegedContainers: true

  # When configure.enabled=true, an additional validation check is performed
  # on the enterprise admin url to ensure it is accessible prior to configuring
  # an organization. In some cloud environments it may take several minutes
  # before the ingress controller is recognized, so adjust this value in minutes, 
  # as needed (formerly validationTimeout).
  configureWaitTimeMin: 15

  ingress:
    #
    # Ingress controller service type
    #
    # Possible values for ingressType:
    #
    #   NodePort        - Exposes the Service on each Node's IP at a static
    #                     port (the NodePort).
    #                     You'll be able to contact the NodePort Service from
    #                     outside the cluster by requesting <NodeIP>:<NodePort>.
    #   LoadBalancer    - Exposes the Service externally using a cloud
    #                     provider's load balancer.
    #                     The load balancer is created and configured
    #                     automatically as a part of the deployment.
    ingressType: NodePort
    #
    # Possible values for loadBalancerType (Must choose one if you plan to
    # provision a cloud load balancer, else leave it blank):
    #
    #   azure-external   - Azure Load Balancer (External)
    #   azure-internal   - Azure Load Balancer (Internal)
    #   aws-nlb-external - AWS Network Load Balancer (External)
    #   aws-nlb-internal - AWS Network Load Balancer (Internal)
    #   gcp-external     - Google Cloud Platform TCP Load Balancer (External)
    #   gcp-internal     - Google Cloud Platform TCP Load Balancer (Internal)
    loadBalancerType:
    #
    # Use a pre-configured static public IP address and DNS label with the
    # load balancer (optional).
    loadBalancerIP:
    #
    # NodePort value in the range 30000-32767. Leave it blank if you want
    # Kubernetes Control Plane to assign an available port.
    nodePortHttps:
    #
    # Set ingressServiceUseClusterIP to true if you plan to use a cluster-level ingress
    # controller or OpenShift route for incoming traffic.
    ingressServiceUseClusterIP: false
    #
    tls:
      # TLS Certificate Option 1: Use an existing Kubernetes TLS secret that
      # contains a private key and a certificate. Enter the name of the
      # existing TLS secret.
      secretName:
      #
      # TLS Certificate Option 4: Generate a self-signed certificate. Enter
      # the common name for the self-signed certificate.
      selfSignCN:

    # HTTP Strict Transport Security
    hstsEnabled: false

    # TLS protocol supported
    sslProtocols: "TLSv1.2 TLSv1.3"

    # Supported Cipher Suites
    sslCiphers: "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-RSA-CHACHA20-POLY1305:AES256-GCM-SHA384:AES256-SHA256:AES256-SHA:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:AES128-GCM-SHA256:AES128-SHA256:AES128-SHA:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA"

    # Custom annotations
    #
    # Allow for additional annotations to be added to the LoadBalancer ingress
    # service created during deployment.
    #
    # You MUST use the following syntax:
    #
    #   - key=value
    #
    # Example:
    #
    # customAnnotations:
    #   - service.beta.kubernetes.io/aws-load-balancer-attributes=deletion_protection.enabled=true,load_balancing.cross_zone.enabled=true
    #   - alb.ingress.kubernetes.io/healthcheck-timeout-seconds=10
    #   - cloud.google.com/app-protocols={"https":"HTTPS"} 
    #
    # You can append additional annotation properties by adding them to the customAnnotations array.
    customAnnotations:
      -
      -

  # If your Kubernetes cluster has a domain name other than cluster.local, use
  # install.k8sClusterDomain to specify the domain name
  k8sClusterDomain: cluster.local

  # If you are deploying ArcGIS Enterprise on Kubernetes and your
  # Kubernetes cluster spans three or more availability zones, update
  # 'kubernetes.io/hostname' to 'topology.kubernetes.io/zone'
  k8sAvailabilityTopologyKey: kubernetes.io/hostname

  # ------------------------------------
  # CLUSTER-LEVEL INGRESS CONTROLLER YAML FILENAME (Optional)
  #
  # If you have indicated that you would like to use a cluster-level ingress
  # controller (by setting INGRESS_SERVICE_USE_CLUSTER_IP=true) for incoming
  # traffic, use one of the YAML templates that can be found in the
  # resources/templates/layer-7-templates folder to create or integrate with a
  # layer 7 load balancer that routes incoming traffic to your ArcGIS Enterprise
  # deployment:
  #
  #    aws-alb-external.yaml.template
  #    aws-alb-internal.yaml.template
  #    azure-agw-ingress-controller.yaml.template
  #    gcp-alb-external.yaml.template
  #    gcp-alb-internal.yaml.template
  #    user-defined-ingress.yaml.template
  #
  # Copy one of these templates locally (remove the .template suffix) and add your
  # load balancer configuration info.
  #
  # Then set clusterIngressControllerYamlFilename to the full path of this
  # file. Since Helm cannot reference files outside of the chart folder you should
  # put this file in the ./user-inputs/ folder and reference that file here.
  #
  # This file can be deleted following a successful deployment. If one of
  # these templates does not apply to your deployment pattern, you can also
  # supply one of your own custom YAML files.
  #
  clusterIngressControllerYamlFilename:

# -----------------------------------------------
# RUN CONFIGURE AFTER DEPLOYMENT
# -----------------------------------------------
configure:
  enabled: true


# -----------------------------------------------
# UPGRADE
# -----------------------------------------------
upgrade:
  
  # ArcGIS Token - A token generated through the sharing/rest/generateToken endpoint.
  token: add_token_here

  # If a release has a mandatory patch-update, we need to specify it here.
  mandatoryUpdateTargetId:

  # Upgrade Target ID. Can refer to releaseId or patchId
  # Do not change this. Download and run helm-charts for different targetIds. 
  targetId: rel_13062024_5814

  # ------------------------------------
  # LICENSE PROPERTIES
  #
  # NOTE: Helm does not support accessing files from outside the Chart folder.
  # For this reason you need to copy your ArcGIS Enterprise on Kubernetes 
  # license file to the ./user-inputs/ folder and reference that file here.
  # ------------------------------------
  licenseFile: user-inputs/my-upgrade-license-file.json
  
  # Todo: Add other upgrade inputs here (if any)


# -----------------------------------------------
# COMMON OPTIONS FOR DEPLOYMENT SCRIPTS
# -----------------------------------------------
common:
  verbose: false

